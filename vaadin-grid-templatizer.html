<!--
@license
Copyright (c) 2017 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<link rel="import" href="../polymer/polymer.html">

<script>
  {
    /**
     * `vaadin-grid-filter` is a helper element for the `vaadin-grid` that provides out-of-the-box UI controls,
     * and handlers for filtering the grid data.
     *
     * @memberof Vaadin
     */
    class GridTemplatizer extends Polymer.Element {
      static get is() {
        return 'vaadin-grid-templatizer';
      }

      static get properties() {
        return {
          dataHost: Object,

          template: Object,

          _templateInstances: {
            type: Array,
            value: function() {
              return [];
            }
          },

          _parentPathValues: {
            value: function() {
              return {};
            }
          },

          _grid: Object
        }
      }

      static get observers() {
        return [
          '_templateInstancesChanged(_templateInstances.*, _parentPathValues.*)'
        ]
      }

      connectedCallback() {
        super.connectedCallback();

        this._instanceProps = {
          expanded: true,
          index: true,
          item: true,
          selected: true
        };
      }

      createInstance() {
        this._ensureTemplatized();
        var instance = new this._TemplateClass({});
        this.addInstance(instance);

        return instance;
      }

      addInstance(instance) {
        if (this._templateInstances.indexOf(instance) === -1) {
          this._templateInstances.push(instance);
          requestAnimationFrame(() => this.notifyPath('_templateInstances.*', this._templateInstances));
        }
      }

      removeInstance(instance) {
        var index = this._templateInstances.indexOf(instance);
        this.splice('_templateInstances', index, 1);
      }

      _ensureTemplatized() {
        // Avoid multiple templatize for the template
        if (!this._TemplateClass) {
          this._TemplateClass = Polymer.Templatize.templatize(this.template, this, {
            instanceProps: this._instanceProps,
            forwardHostProp: this._forwardHostPropV2
          });

          this._parentProps = this._parentProps || {};
        }
      }


      _notifyInstancePropV2(inst, prop, value) {
        if (prop === 'index' || prop === 'item') {
          // We donâ€™t need a change notification for these.
          return;
        }

        var originalProp = `__${prop}__`;

        // Notify for only user-action changes, not for scrolling updates. E. g.,
        // if `expanded` is different from `__expanded__`, which was set during render.
        if (inst[originalProp] === value) {
          return;
        }
        inst[originalProp] = value;

        const row = Array.from(this._grid.$.items.children).filter(row => row._item === inst.item)[0];
        if (row) {
          Array.from(row.children).forEach(cell => {
            cell._instance[originalProp] = value;
            cell._instance.notifyPath(prop, value);
          });
        }

        var gridCallback = `_${prop}InstanceChangedCallback`;
        if (this._grid && this._grid[gridCallback]) {
          this._grid[gridCallback](inst, value);
        }
      }

      _forwardParentProp(prop, value) {
        this._parentPathValues[prop] = value;
        this._templateInstances.forEach(function(inst) {
          inst.set(prop, value);
        }, this);
      }

      _forwardParentPath(path, value) {
        this.set(['_parentPathValues', path], value);
        this._templateInstances.forEach(function(inst) {
          inst.notifyPath(path, value);
        }, this);
      }

      _forwardHostPropV2(prop, value) {
        this._forwardParentProp(prop, value);

        // TODO: _forwardedParentPropsChanged isn't triggered for some reason in
        // all cases in Hybrid mode. Try removing this after running pure P2.
        if (this._templateInstances) {
          this._templateInstances.forEach(function(inst) {
            inst.notifyPath(prop, value);
          }, this);
        }
      }

      _templateInstancesChanged(t, p) {
        var index, count;
        if (t.path === '_templateInstances') {
          // Iterate all instances
          index = 0;
          count = this._templateInstances.length;
        } else if (t.path === '_templateInstances.splices') {
          // Iterate only new instances
          index = t.value.index;
          count = t.value.addedCount;
        } else {
          return;
        }
        Object.keys(this._parentPathValues || {}).forEach(function(keyName) {
          for (var i = index; i < index + count; i++) {
            this._templateInstances[i].set(keyName, this._parentPathValues[keyName]);
          }
        }, this);
      }

    }

    customElements.define(GridTemplatizer.is, GridTemplatizer);

    /**
     * @namespace Vaadin
     */
    window.Vaadin = window.Vaadin || {};
    Vaadin.GridTemplatizer = GridTemplatizer;
  }
</script>
